%
% automatically generated by HelpGen $Revision$ from
% controlbar.h at 05/Jan/02 22:50:58
%


\section{\class{wxFrameLayout}}\label{wxframelayout}


wxFrameLayout manages containment and docking of control bars.
   which can be docked along top, bottom, righ, or left side of the
   parent frame
 
\wxheading{Derived from}

\helpref{wxEvtHandler}{wxevthandler}

\wxheading{Data structures}

\latexignore{\rtfignore{\wxheading{Members}}}


\membersection{wxFrameLayout::wxFrameLayout}\label{wxframelayoutwxframelayout}

\func{}{wxFrameLayout}{\param{wxWindow* }{pParentFrame}, \param{wxWindow* }{pFrameClient = NULL}, \param{bool }{activateNow = TRUE}}


\func{}{wxFrameLayout}{\void}

used only while serializing


\membersection{wxFrameLayout::\destruct{wxFrameLayout}}\label{wxframelayoutdtor}

\func{}{\destruct{wxFrameLayout}}{\void}

(doesn't destroy bar windows)


\membersection{wxFrameLayout::Activate}\label{wxframelayoutactivate}

\func{void}{Activate}{\void}

Can be called after some other layout has been deactivated,
and this one must "take over" the current contents of frame window.
Effectively hooks itself to the frame window, re-displays all not-hidden
bar-windows and repaints decorations


\membersection{wxFrameLayout::AddBar}\label{wxframelayoutaddbar}

\func{void}{AddBar}{\param{wxWindow* }{pBarWnd}, \param{const cbDimInfo\& }{dimInfo}, \param{int }{alignment = FL\_ALIGN\_TOP}, \param{int }{rowNo = 0}, \param{int }{columnPos = 0}, \param{const wxString\& }{name = "bar"}, \param{bool }{spyEvents = FALSE}, \param{int }{state = wxCBAR\_DOCKED\_HORIZONTALLY}}

Adds bar information to frame-layout, appearence of layout is not refreshed
immediately, RefreshNow() can be called if necessary.
NOTES:: argument pBarWnd can by NULL, resulting bar decorations to be drawn
around the empty rectangle (filled with default background colour).
Argument dimInfo, can be re-used for adding any number of bars, since
it is not used directly, instead it's members are copied. If dimensions-
handler is present, it's instance shared (reference counted). Dimension
handler should always be allocated on the heap!)


\membersection{wxFrameLayout::AddPlugin}\label{wxframelayoutaddplugin}

\func{void}{AddPlugin}{\param{wxClassInfo* }{pPlInfo}, \param{int }{paneMask = wxALL\_PANES}}

"Advanced" methods for plugin-configuration	using their dynamic class information (e.g. CLASSINFO(pluginClass) ) first checks if plugin of the given class is already "hooked up",
if not, adds it to the top of plugins chain


\membersection{wxFrameLayout::AddPluginBefore}\label{wxframelayoutaddpluginbefore}

\func{void}{AddPluginBefore}{\param{wxClassInfo* }{pNextPlInfo}, \param{wxClassInfo* }{pPlInfo}, \param{int }{paneMask = wxALL\_PANES}}

first checks if plugin of the givne class already hooked,
if so, removes it, and then inserts it to the chain
before plugin of the class given by "pNextPlInfo"
NOTE:: this method is "handy" in some cases, where the order
of plugin-chain could be important, e.g. one plugin overrides
some functionallity of the other already hooked plugin,
thefore the former should be hooked before the one
who's functionality is being overriden


\membersection{wxFrameLayout::ApplyBarProperties}\label{wxframelayoutapplybarproperties}

\func{void}{ApplyBarProperties}{\param{cbBarInfo* }{pBar}}

reflects changes in bar information structure visually
(e.g. moves bar, changes it's dimension info, pane to which it is docked)


\membersection{wxFrameLayout::CanReparent}\label{wxframelayoutcanreparent}

\func{bool}{CanReparent}{\void}

NOTE:: reparenting of windows may NOT work on all platforms
(reparenting allows control-bars to be floated)


\membersection{wxFrameLayout::CaptureEventsForPane}\label{wxframelayoutcaptureeventsforpane}

\func{void}{CaptureEventsForPane}{\param{cbDockPane* }{toPane}}

called by plugins ( also captures/releases mouse in parent frame)


\membersection{wxFrameLayout::CaptureEventsForPlugin}\label{wxframelayoutcaptureeventsforplugin}

\func{void}{CaptureEventsForPlugin}{\param{cbPluginBase* }{pPlugin}}

captures/releases user-input event's for the given plugin
Input events are: mouse movement, mouse clicks, keyboard input


\membersection{wxFrameLayout::CreateCursors}\label{wxframelayoutcreatecursors}

\func{void}{CreateCursors}{\void}


\membersection{wxFrameLayout::CreateUpdatesManager}\label{wxframelayoutcreateupdatesmanager}

\func{cbUpdatesManagerBase*}{CreateUpdatesManager}{\void}

factory method


\membersection{wxFrameLayout::Deactivate}\label{wxframelayoutdeactivate}

\func{void}{Deactivate}{\void}

unhooks itself from frame window, and hides all not-hidden windows
NOTE:: two frame-layouts should not be active at the same time in the
same frame window, it would cause messy overlapping of bar windows
from both layouts


\membersection{wxFrameLayout::DestroyBarWindows}\label{wxframelayoutdestroybarwindows}

\func{void}{DestroyBarWindows}{\void}


\membersection{wxFrameLayout::DoSetBarState}\label{wxframelayoutdosetbarstate}

\func{void}{DoSetBarState}{\param{cbBarInfo* }{pBar}}


\membersection{wxFrameLayout::EnableFloating}\label{wxframelayoutenablefloating}

\func{void}{EnableFloating}{\param{bool }{enable = TRUE}}

(by default floating of control-bars is ON)


\membersection{wxFrameLayout::FindBarByName}\label{wxframelayoutfindbarbyname}

\func{cbBarInfo*}{FindBarByName}{\param{const wxString\& }{name}}

methods for access and modification of bars in frame layout


\membersection{wxFrameLayout::FindBarByWindow}\label{wxframelayoutfindbarbywindow}

\func{cbBarInfo*}{FindBarByWindow}{\param{const wxWindow* }{pWnd}}


\membersection{wxFrameLayout::FindPlugin}\label{wxframelayoutfindplugin}

\func{cbPluginBase*}{FindPlugin}{\param{wxClassInfo* }{pPlInfo}}

returns NULL, if plugin of the given class is not hooked


\membersection{wxFrameLayout::FirePluginEvent}\label{wxframelayoutfirepluginevent}

\func{void}{FirePluginEvent}{\param{cbPluginEvent\& }{event}}

plugin-related methods **should be used, instead of passing the event to ProcessEvent(..) method
of the top-plugin directly. This method checks if events are currently
captured and ensures that plugin-event is routed correctly.


\membersection{wxFrameLayout::ForwardMouseEvent}\label{wxframelayoutforwardmouseevent}

\func{void}{ForwardMouseEvent}{\param{wxMouseEvent\& }{event}, \param{cbDockPane* }{pToPane}, \param{int }{eventType}}

delegated from "bar-spy"


\membersection{wxFrameLayout::GetBarPane}\label{wxframelayoutgetbarpane}

\func{cbDockPane*}{GetBarPane}{\param{cbBarInfo* }{pBar}}

returns panes, to which the given bar belongs


\membersection{wxFrameLayout::GetBars}\label{wxframelayoutgetbars}

\func{BarArrayT\&}{GetBars}{\void}


\membersection{wxFrameLayout::GetClientHeight}\label{wxframelayoutgetclientheight}

\func{int}{GetClientHeight}{\void}


\membersection{wxFrameLayout::GetClientRect}\label{wxframelayoutgetclientrect}

\func{wxRect\&}{GetClientRect}{\void}


\membersection{wxFrameLayout::GetClientWidth}\label{wxframelayoutgetclientwidth}

\func{int}{GetClientWidth}{\void}


\membersection{wxFrameLayout::GetFrameClient}\label{wxframelayoutgetframeclient}

\func{wxWindow*}{GetFrameClient}{\void}


\membersection{wxFrameLayout::GetPane}\label{wxframelayoutgetpane}

\func{cbDockPane*}{GetPane}{\param{int }{alignment}}

see pane alignment types


\membersection{wxFrameLayout::GetPaneProperties}\label{wxframelayoutgetpaneproperties}

\func{void}{GetPaneProperties}{\param{cbCommonPaneProperties\& }{props}, \param{int }{alignment = FL\_ALIGN\_TOP}}

NOTE:: changing properties of panes, does not result immediate on-screen update


\membersection{wxFrameLayout::GetPanesArray}\label{wxframelayoutgetpanesarray}

\func{cbDockPane**}{GetPanesArray}{\void}

used by updates-managers


\membersection{wxFrameLayout::GetParentFrame}\label{wxframelayoutgetparentframe}

\func{wxWindow\&}{GetParentFrame}{\void}


\membersection{wxFrameLayout::GetPrevClientRect}\label{wxframelayoutgetprevclientrect}

\func{wxRect\&}{GetPrevClientRect}{\void}


\membersection{wxFrameLayout::GetTopPlugin}\label{wxframelayoutgettopplugin}

\func{cbPluginBase\&}{GetTopPlugin}{\void}

returns current top-level plugin (the one which receives events first,
with an exception if input-events are currently captured by some other plugin)


\membersection{wxFrameLayout::GetUpdatesManager}\label{wxframelayoutgetupdatesmanager}

\func{cbUpdatesManagerBase\&}{GetUpdatesManager}{\void}

NOTE:: in future ubdates-manager will become a normal plugin


\membersection{wxFrameLayout::HasTopPlugin}\label{wxframelayouthastopplugin}

\func{bool}{HasTopPlugin}{\void}


\membersection{wxFrameLayout::HideBarWindows}\label{wxframelayouthidebarwindows}

\func{void}{HideBarWindows}{\void}

also hides the client window if presents


\membersection{wxFrameLayout::HitTestPane}\label{wxframelayouthittestpane}

\func{bool}{HitTestPane}{\param{cbDockPane* }{pPane}, \param{int }{x}, \param{int }{y}}


\membersection{wxFrameLayout::HitTestPanes}\label{wxframelayouthittestpanes}

\func{cbDockPane*}{HitTestPanes}{\param{const wxRect\& }{rect}, \param{cbDockPane* }{pCurPane}}


\membersection{wxFrameLayout::HookUpToFrame}\label{wxframelayouthookuptoframe}

\func{void}{HookUpToFrame}{\void}


\membersection{wxFrameLayout::InverseVisibility}\label{wxframelayoutinversevisibility}

\func{void}{InverseVisibility}{\param{cbBarInfo* }{pBar}}


\membersection{wxFrameLayout::LocateBar}\label{wxframelayoutlocatebar}

\func{bool}{LocateBar}{\param{cbBarInfo* }{pBarInfo}, \param{cbRowInfo** }{ppRow}, \param{cbDockPane** }{ppPane}}


\membersection{wxFrameLayout::OnActivate}\label{wxframelayoutonactivate}

\func{void}{OnActivate}{\param{wxActivateEvent\& }{event}}


\membersection{wxFrameLayout::OnEraseBackground}\label{wxframelayoutonerasebackground}

\func{void}{OnEraseBackground}{\param{wxEraseEvent\& }{event}}


\membersection{wxFrameLayout::OnIdle}\label{wxframelayoutonidle}

\func{void}{OnIdle}{\param{wxIdleEvent\& }{event}}


\membersection{wxFrameLayout::OnKillFocus}\label{wxframelayoutonkillfocus}

\func{void}{OnKillFocus}{\param{wxFocusEvent\& }{event}}


\membersection{wxFrameLayout::OnLButtonDown}\label{wxframelayoutonlbuttondown}

\func{void}{OnLButtonDown}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnLButtonUp}\label{wxframelayoutonlbuttonup}

\func{void}{OnLButtonUp}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnLDblClick}\label{wxframelayoutonldblclick}

\func{void}{OnLDblClick}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnMouseMove}\label{wxframelayoutonmousemove}

\func{void}{OnMouseMove}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnPaint}\label{wxframelayoutonpaint}

\func{void}{OnPaint}{\param{wxPaintEvent\& }{event}}


\membersection{wxFrameLayout::OnRButtonDown}\label{wxframelayoutonrbuttondown}

\func{void}{OnRButtonDown}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnRButtonUp}\label{wxframelayoutonrbuttonup}

\func{void}{OnRButtonUp}{\param{wxMouseEvent\& }{event}}


\membersection{wxFrameLayout::OnSetFocus}\label{wxframelayoutonsetfocus}

\func{void}{OnSetFocus}{\param{wxFocusEvent\& }{event}}


\membersection{wxFrameLayout::OnSize}\label{wxframelayoutonsize}

\func{void}{OnSize}{\param{wxSizeEvent\& }{event}}

event handlers


\membersection{wxFrameLayout::PopAllPlugins}\label{wxframelayoutpopallplugins}

\func{void}{PopAllPlugins}{\void}


\membersection{wxFrameLayout::PopPlugin}\label{wxframelayoutpopplugin}

\func{void}{PopPlugin}{\void}


\membersection{wxFrameLayout::PositionClientWindow}\label{wxframelayoutpositionclientwindow}

\func{void}{PositionClientWindow}{\void}

called to set calculated layout to window objects


\membersection{wxFrameLayout::PositionPanes}\label{wxframelayoutpositionpanes}

\func{void}{PositionPanes}{\void}


\membersection{wxFrameLayout::PushDefaultPlugins}\label{wxframelayoutpushdefaultplugins}

\func{void}{PushDefaultPlugins}{\void}

default plugins are : cbPaneDrawPlugin, cbRowLayoutPlugin, cbBarDragPlugin,
cbAntiflickerPlugin, cbSimpleCustomizePlugin
this method is automatically invoked, if no plugins were found upon
fireing of the first plugin-event, i.e. wxFrameLayout *CONFIGURES* itself


\membersection{wxFrameLayout::PushPlugin}\label{wxframelayoutpushplugin}

\func{void}{PushPlugin}{\param{cbPluginBase* }{pPugin}}

similar to wxWindow's "push/pop-event-handler" methods, execept
that plugin is *deleted* upon "popping"


\membersection{wxFrameLayout::RecalcLayout}\label{wxframelayoutrecalclayout}

\func{void}{RecalcLayout}{\param{bool }{repositionBarsNow = FALSE}}

recalcualtes layout of panes, and all bars/rows in each pane


\membersection{wxFrameLayout::RedockBar}\label{wxframelayoutredockbar}

\func{bool}{RedockBar}{\param{cbBarInfo* }{pBar}, \param{const wxRect\& }{shapeInParent}, \param{cbDockPane* }{pToPane = NULL}, \param{bool }{updateNow = TRUE}}

can be used for repositioning already existing bars. The given bar is first removed
from the pane it currently belongs to, and inserted into the pane, which "matches"
the given recantular area. If pToPane is not NULL, bar is docked to this given pane
to dock the bar which is floated, use wxFrameLayout::DockBar(..) method


\membersection{wxFrameLayout::RefreshNow}\label{wxframelayoutrefreshnow}

\func{void}{RefreshNow}{\param{bool }{recalcLayout = TRUE}}

recalculates layoute and performs on-screen update of all panes


\membersection{wxFrameLayout::ReleaseEventsFromPane}\label{wxframelayoutreleaseeventsfrompane}

\func{void}{ReleaseEventsFromPane}{\param{cbDockPane* }{fromPane}}


\membersection{wxFrameLayout::ReleaseEventsFromPlugin}\label{wxframelayoutreleaseeventsfromplugin}

\func{void}{ReleaseEventsFromPlugin}{\param{cbPluginBase* }{pPlugin}}


\membersection{wxFrameLayout::RemoveBar}\label{wxframelayoutremovebar}

\func{void}{RemoveBar}{\param{cbBarInfo* }{pBar}}

removes bar from layout permanently, hides it's corresponding window if present


\membersection{wxFrameLayout::RemovePlugin}\label{wxframelayoutremoveplugin}

\func{void}{RemovePlugin}{\param{wxClassInfo* }{pPlInfo}}

checks if plugin of the given class is hooked, removes
it if found
@param pPlInfo class information structure for the plugin
@note
@see wxFrameLayout::Method


\membersection{wxFrameLayout::ReparentWindow}\label{wxframelayoutreparentwindow}

\func{void}{ReparentWindow}{\param{wxWindow* }{pChild}, \param{wxWindow* }{pNewParent}}


\membersection{wxFrameLayout::RepositionFloatedBar}\label{wxframelayoutrepositionfloatedbar}

\func{void}{RepositionFloatedBar}{\param{cbBarInfo* }{pBar}}


\membersection{wxFrameLayout::RouteMouseEvent}\label{wxframelayoutroutemouseevent}

\func{void}{RouteMouseEvent}{\param{wxMouseEvent\& }{event}, \param{int }{pluginEvtType}}


\membersection{wxFrameLayout::SetBarState}\label{wxframelayoutsetbarstate}

\func{void}{SetBarState}{\param{cbBarInfo* }{pBar}, \param{int }{newStatem}, \param{bool }{updateNow}}

changes bar's docking state (see possible control bar states)


\membersection{wxFrameLayout::SetFrameClient}\label{wxframelayoutsetframeclient}

\func{void}{SetFrameClient}{\param{wxWindow* }{pFrameClient}}

passes the client window (e.g. MDI-client frame) to be controled by
frame layout, the size and position of which should be adjusted to be
surrounded by controlbar panes, whenever frame is resized, or dimensions
of control panes change


\membersection{wxFrameLayout::SetMargins}\label{wxframelayoutsetmargins}

\func{void}{SetMargins}{\param{int }{top}, \param{int }{bottom}, \param{int }{left}, \param{int }{right}, \param{int }{paneMask = wxALL\_PANES}}

TODO:: margins should go into cbCommonPaneProperties in the future
NOTE:: this method should be called before any custom plugins are attached


\membersection{wxFrameLayout::SetPaneBackground}\label{wxframelayoutsetpanebackground}

\func{void}{SetPaneBackground}{\param{const wxColour\& }{colour}}


\membersection{wxFrameLayout::SetPaneProperties}\label{wxframelayoutsetpaneproperties}

\func{void}{SetPaneProperties}{\param{const cbCommonPaneProperties\& }{props}, \param{int }{paneMask = wxALL\_PANES}}


\membersection{wxFrameLayout::SetTopPlugin}\label{wxframelayoutsettopplugin}

\func{void}{SetTopPlugin}{\param{cbPluginBase* }{pPlugin}}

hooking custom plugins to frame layout
NOTE:: when hooking one plugin on top of the other -
use SetNextHandler(..) or similar methods
of wxEvtHandler class to compose the chain of plugins,
than pass the left-most handler in this chain to
the above methods (assuming that events are delegated
from left-most towards right-most handler)
NOTE2:: this secenario is very inconvenient and "low-level",
use Add/Push/PopPlugin methods instead


\membersection{wxFrameLayout::SetUpdatesManager}\label{wxframelayoutsetupdatesmanager}

\func{void}{SetUpdatesManager}{\param{cbUpdatesManagerBase* }{pUMgr}}

destroys the previous manager if any, set the new one


\membersection{wxFrameLayout::ShowFloatedWindows}\label{wxframelayoutshowfloatedwindows}

\func{void}{ShowFloatedWindows}{\param{bool }{show}}


\membersection{wxFrameLayout::UnhookFromFrame}\label{wxframelayoutunhookfromframe}

\func{void}{UnhookFromFrame}{\void}

