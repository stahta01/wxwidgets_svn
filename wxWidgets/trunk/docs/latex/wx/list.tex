%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Name:        list.tex
%% Purpose:     wxList
%% Author:      wxWidgets Team
%% Modified by:
%% Created:
%% RCS-ID:      $Id$
%% Copyright:   (c) wxWidgets Team
%% License:     wxWindows license
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{\class{wxList<T>}}\label{wxlist}

The wxList<T> class provides linked list functionality. It has been written
to be type safe and to provide the full API of the STL std::list container and
should be used like it. The exception is that wxList<T> actually stores
pointers and therefore its iterators return pointers and not references
to the actual objets in the list (see example below). Unfortunately, the
new wxList<T> class requires that you declare and define each wxList<T>
class in your program. This is done with {\it WX\_DECLARE\_LIST} and 
{\it WX\_DEFINE\_LIST} macros (see example). We hope that we'll be able
to provide a proper template class providing both the STL std::list
and the old wxList API in the future.

Please refer to the STL std::list documentation for further
information on how to use the class. Below we documented the legacy
API that originated from the old wxList class and which can still 
be used alternatively for the the same class.

Note that if you compile wxWidgets in STL mode (wxUSE_STL defined as 1) 
then wxList<T> will actually derive from std::list and just add a legacy 
compatibility layer for the old wxList class.

each list type (i.e. list of ints, of wxStrings or of MyObjects). 

\wxheading{Example}

\begin{verbatim}
    // this part might be in a header or source (.cpp) file
    class MyListElement
    {
        ... // whatever
    };

    // this macro declares and partly implements MyList class
    WX_DECLARE_LIST(MyListElement, MyList);

    ...

    // the only requirement for the rest is to be AFTER the full declaration of
    // MyListElement (for WX_DECLARE_LIST forward declaration is enough), but
    // usually it will be found in the source file and not in the header

    #include <wx/listimpl.cpp>
    WX_DEFINE_LIST(MyList);



    MyList list;
    MyListElement element;
    list.Append(&element);     // ok
    list.Append(17);           // error: incorrect type

    // let's iterate over the list in STL syntax
    MyList::iterator iter;
    for (iter = list.begin(); iter != list.end(); ++iter)
    {
        MyListElement *current = *iter;

        ...process the current element...
    }

    // the same with the legacy API from the old wxList class
    MyList::compatibility_iterator node = list.GetFirst();
    while (node)
    {
        MyListElement *current = node->GetData();

        ...process the current element...
        
        node = node->GetNext();
    }

\end{verbatim}

For compatibility with previous versions wxList and wxStringList classes are
still defined, but their usage is deprecated and they will disappear in the
future versions completely. The use of the latter is especially discouraged as
it is not only unsafe but is also much less efficient than
\helpref{wxArrayString}{wxarraystring} class.

\wxheading{Include files}

<wx/list.h>

\wxheading{See also}

\helpref{wxArray}{wxarray}

\latexignore{\rtfignore{\wxheading{Members}}}

\membersection{wxList<T>::wxList<T>}\label{wxlistctor}

\func{}{wxList<T>}{\void}

\func{}{wxList<T>}{\param{size_t}{ count}, \param{T *}{elements[]}}

Constructors.

\membersection{wxList<T>::\destruct{wxList<T>}}\label{wxlistdtor}

\func{}{\destruct{wxList<T>}}{\void}

Destroys the list, but does not delete the objects stored in the list
unless you called DeleteContents({\tt true} ).

\membersection{wxList<T>::Append}\label{wxlistappend}

\func{wxList<T>::compatibility_iterator }{Append}{\param{T *}{object}}

Appends the pointer to \rtfsp{\it object} to the list.

\membersection{wxList<T>::Clear}\label{wxlistclear}

\func{void}{Clear}{\void}

Clears the list, but does not delete the objects stored in the list
unless you called DeleteContents({\tt true} ).

\membersection{wxList<T>::DeleteContents}\label{wxlistdeletecontents}

\func{void}{DeleteContents}{\param{bool}{ destroy}}

If {\it destroy} is {\tt true}, instructs the list to call {\it delete}
on objects stored in the list whenever they are removed.
The default is {\tt false}.

\membersection{wxList<T>::DeleteNode}\label{wxlistdeletenode}

\func{bool}{DeleteNode}{\param{const compatibility_iterator &}{iter}}

Deletes the given element refered to by {\tt iter} from the list, 
returning {\tt true} if successful.

\membersection{wxList<T>::DeleteObject}\label{wxlistdeleteobject}

\func{bool}{DeleteObject}{\param{T *}{object}}

Finds the given {\it object} and removes it from the list, returning
{\tt true} if successful. The application must delete the actual object
separately.

\membersection{wxList<T>::Erase}\label{wxlisterase}

\func{void}{Erase}{\param{const compatibility_iterator &}{iter}}

Removes element refered to be {\tt iter}.

\membersection{wxList<T>::Find}\label{wxlistfind}

\constfunc{wxList<T>::compatibility_iterator}{Find}{\param{T *}{ object}}

Returns the iterator refering to {\it object} or NULL if none found.

\membersection{wxList<T>::GetCount}\label{wxlistgetcount}

\constfunc{size\_t}{GetCount}{\void}

Returns the number of elements in the list.

\membersection{wxList<T>::GetFirst}\label{wxlistgetfirst}

\constfunc{wxList<T>::compatibility_iterator}{GetFirst}{\void}

Returns the first iterator in the list (NULL if the list is empty).

\membersection{wxList<T>::GetLast}\label{wxlistgetlast}

\constfunc{wxList<T>::compatibility_iterator}{GetLast}{\void}

Returns the last iterator in the list (NULL if the list is empty).

\membersection{wxList<T>::IndexOf}\label{wxlistindexof}

\constfunc{int}{IndexOf}{\param{T*}{ obj }}

Returns the index of {\it obj} within the list or {\tt wxNOT\_FOUND} if
{\it obj} is not found in the list.

\membersection{wxList<T>::Insert}\label{wxlistinsert}

\func{wxList<T>::compatibility_iterator}{Insert}{\param{T *}{object}}

Insert object at the front of list.

\func{wxList<T>::compatibility_iterator}{Insert}{\param{size\_t }{position}, \param{T *}{object}}

Insert object before {\it position}, i.e. the index of the new item in the
list will be equal to {\it position}. {\it position} should be less than or
equal to \helpref{GetCount}{wxlistgetcount}; if it is equal to it, this is the
same as calling \helpref{Append}{wxlistappend}.

\func{wxList<T>::compatibility_iterator}{Insert}{\param{compatibility_iterator}{iter}, \param{T *}{object}}

Inserts the object before the object refered to be {\it iter}.

\membersection{wxList<T>::IsEmpty}\label{wxlistisempty}

\constfunc{bool}{IsEmpty}{\void}

Returns {\tt true} if the list is empty, {\tt false} otherwise.

% Use different label name to avoid clashing with wxListItem label
\membersection{wxList<T>::Item}\label{wxlistitemfunc}

\constfunc{wxList<T>::compatibility_iterator}{Item}{\param{size\_t }{index}}

Returns the iterator refering to the object at the given
{\tt index} in the list.

\membersection{wxList<T>::Member}\label{wxlistmember}

\constfunc{wxList<T>::compatibility_iterator}{Member}{\param{T *}{ object}}

{\bf NB:} This function is deprecated, use \helpref{Find}{wxlistfind} instead.

\membersection{wxList<T>::Nth}\label{wxlistnth}

\constfunc{wxList<T>::compatibility_iterator}{Nth}{\param{int }{n}}

{\bf NB:} This function is deprecated, use \helpref{Item}{wxlistitemfunc} instead.

Returns the {\it nth} node in the list, indexing from zero (NULL if the list is empty
or the nth node could not be found).

\membersection{wxList<T>::Number}\label{wxlistnumber}

\constfunc{int}{Number}{\void}

{\bf NB:} This function is deprecated, use \helpref{GetCount}{wxlistgetcount} instead.

Returns the number of elements in the list.

\membersection{wxList<T>::Sort}\label{wxlistsort}

\func{void}{Sort}{\param{wxSortCompareFunction}{ compfunc}}

\begin{verbatim}
  // Type of compare function for list sort operation (as in 'qsort')
  typedef int (*wxSortCompareFunction)(const void *elem1, const void *elem2);
\end{verbatim}

Allows the sorting of arbitrary lists by giving a function to compare
two list elements. We use the system {\bf qsort} function for the actual
sorting process.

