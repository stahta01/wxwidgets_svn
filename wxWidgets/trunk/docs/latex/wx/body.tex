\chapter{Introduction}\label{introduction}
\pagenumbering{arabic}%
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

\section{What is wxWindows?}

wxWindows is a C++ framework providing GUI (Graphical User
Interface) and other facilities on more than one platform.  Version 2 currently
supports all desktop versions of MS Windows, Unix with GTK+, Unix with Motif,
and MacOS. An OS/2 port is in progress.

wxWindows was originally developed at the Artificial Intelligence
Applications Institute, University of Edinburgh, for internal use,
and was first made publicly available in 1992.
Version 2 is a vastly improved version written and maintained by
Julian Smart, Robert Roebling, Vadim Zeitlin, Vaclav Slavik and many others.

This manual contains a class reference and topic overviews.
For a selection of wxWindows tutorials, please see the documentation page on the \urlref{wxWindows web site}{http://www.wxwindows.org}.

Please note that in the following, ``MS Windows" often refers to all
platforms related to Microsoft Windows, including 16-bit and 32-bit
variants, unless otherwise stated. All trademarks are acknowledged.

\section{Why another cross-platform development tool?}

wxWindows was developed to provide a cheap and flexible way to maximize
investment in GUI application development.  While a number of commercial
class libraries already existed for cross-platform development,
none met all of the following criteria:

\begin{enumerate}\itemsep=0pt
\item low price;
\item source availability;
\item simplicity of programming;
\item support for a wide range of compilers.
\end{enumerate}

Since wxWindows was started, several other free or almost-free
GUI frameworks have emerged. However, none has the range of
features, flexibility, documentation and the well-established
development team that wxWindows has.

As open source software, wxWindows has benefited from comments,
ideas, bug fixes, enhancements and the sheer enthusiasm of
users. This gives wxWindows a certain advantage over its
commercial competitors (and over free libraries without an
independent development team), plus a robustness against the
transience of one individual or company. This openness and
availability of source code is especially important when the
future of thousands of lines of application code may depend upon
the longevity of the underlying class library.

Version 2 goes much further than previous versions in terms of
generality and features, allowing applications to be produced
that are often indistinguishable from those produced using
single-platform toolkits such as Motif, GTK+ and MFC.

The importance of using a platform-independent class library
cannot be overstated, since GUI application development is very
time-consuming, and sustained popularity of particular GUIs
cannot be guaranteed. Code can very quickly become obsolete if
it addresses the wrong platform or audience.  wxWindows helps to
insulate the programmer from these winds of change. Although
wxWindows may not be suitable for every application (such as an
OLE-intensive program), it provides access to most of the
functionality a GUI program normally requires, plus many extras
such as network programming, PostScript output, and HTML
rendering; and it can of course be extended as needs dictate.
As a bonus, it provides a far cleaner and easier programming
interface than the native APIs. Programmers may find it
worthwhile to use wxWindows even if they are developing on only
one platform.

It is impossible to sum up the functionality of wxWindows in a few paragraphs, but
here are some of the benefits:

\begin{itemize}\itemsep=0pt
\item Low cost (free, in fact!)
\item You get the source.
\item Available on a variety of popular platforms.
\item Works with almost all popular C++ compilers and Python.
\item Over 50 example programs.
\item Over 1000 pages of printable and on-line documentation.
\item Includes Tex2RTF, to allow you to produce your own documentation
in Windows Help, HTML and Word RTF formats.
\item Simple-to-use, object-oriented API.
\item Flexible event system.
\item Graphics calls include lines, rounded rectangles, splines, polylines, etc.
\item Constraint-based and sizer-based layouts.
\item Print/preview and document/view architectures.
\item Toolbar, notebook, tree control, advanced list control classes.
\item PostScript generation under Unix, normal MS Windows printing on the PC.
\item MDI (Multiple Document Interface) support.
\item Can be used to create DLLs under Windows, dynamic libraries on Unix.
\item Common dialogs for file browsing, printing, colour selection, etc.
\item Under MS Windows, support for creating metafiles and copying
them to the clipboard.
\item An API for invoking help from applications.
\item Ready-to-use HTML window (supporting a subset of HTML).
\item Dialog Editor for building dialogs.
\item Network support via a family of socket and protocol classes.
\item Support for platform independent image processing.
\item Built-in support for many file formats (BMP, PNG, JPEG, GIF, XPM, PNM, PCX).
\end{itemize}

\begin{comment}
\section{Changes from version 2.0}\label{versionchanges20}

These are a few of the differences between versions 2.0 and 2.2.

Removals:

\begin{itemize}\itemsep=0pt
\item GTK 1.0 no longer supported.
\end{itemize}

Additions and changes:

\begin{itemize}\itemsep=0pt
\item Corrected many classes to conform better to documented behaviour.
\item Added handlers for more image formats (Now GIF, JPEG, PCX, BMP, XPM, PNG, PNM).
\item Improved support for socket and network functions.
\item Support for different national font encodings.
\item Sizer based layout system.
\item HTML widget and help system.
\item Added some controls (e.g. wxSpinCtrl) and supplemented many.
\item Many optical improvements to GTK port.
\item Support for menu accelerators in GTK port.
\item Enhanced and improved support for scrolling, including child windows.
\item Complete rewrite of clipboard and drag and drop classes.
\item Improved support for ODBC databases.
\item Improved tab traversal in dialogs.
\end{itemize}
\end{comment}

\section{wxWindows requirements}\label{requirements}

To make use of wxWindows, you currently need one of the following setups.

(a) MS-Windows:

\begin{enumerate}\itemsep=0pt
\item A 486 or higher PC running MS Windows.
\item A Windows compiler: most are supported, but please see {\tt install.txt} for
details. Supported compilers include Microsoft Visual C++ 4.0 or higher, Borland C++, Cygwin,
Metrowerks CodeWarrior.
\item At least 60 MB of disk space.
\end{enumerate}

(b) Unix:

\begin{enumerate}\itemsep=0pt
\item Almost any C++ compiler, including GNU C++ (EGCS 1.1.1 or above).
\item Almost any Unix workstation, and one of: GTK+ 1.2, GTK+ 2.0, Motif 1.2 or higher, Lesstif.
\item At least 60 MB of disk space.
\end{enumerate}

(c) Mac OS/Mac OS X:

\begin{enumerate}\itemsep=0pt
\item A PowerPC Mac running Mac OS 8.6/9.x (eg. Classic) or Mac OS X 10.x.
\item CodeWarrior 5.3, 6 or 7 for Classic Mac OS.
\item The Apple Developer Tools (eg. GNU C++) or CodeWarrior 7 for Mac OS X.
\item At least 60 MB of disk space.
\end{enumerate}

\section{Availability and location of wxWindows}

\winhelponly{wxWindows is available by anonymous FTP and World Wide Web
from ftp://biolpc22.york.ac.uk/pub and/or http://www.wxwindows.org.}
\winhelpignore{wxWindows is available by anonymous FTP and World Wide Web
from \urlref{ftp://biolpc22.york.ac.uk/pub}{ftp://biolpc22.york.ac.uk/pub} 
and/or \urlref{http://www.wxwindows.org}{http://www.wxwindows.org}.}

You can also buy a CD-ROM using the form on the Web site.

\section{Acknowledgements}

Thanks are due to AIAI for being willing to release the original version of
wxWindows into the public domain, and to our patient partners.

We would particularly like to thank the following for their contributions to wxWindows, and the many others who have been involved in
the project over the years. Apologies for any unintentional omissions from this list. 
 
Yiorgos Adamopoulos, Jamshid Afshar, Alejandro Aguilar-Sierra, AIAI, Patrick Albert, Karsten Ballueder, Michael Bedward, Kai Bendorf, Yura Bidus, Keith 
Gary Boyce, Chris Breeze, Pete Britton, Ian Brown, C. Buckley, Dmitri Chubraev, Robin Corbet, Cecil Coupe, Andrew Davison, Neil Dudman, Robin 
Dunn, Hermann Dunkel, Jos van Eijndhoven, Tom Felici, Thomas Fettig, Matthew Flatt, Pasquale Foggia, Josep Fortiana, Todd Fries, Dominic Gallagher, 
Guillermo Rodriguez Garcia, Wolfram Gloger, Norbert Grotz, Stefan Gunter, Bill Hale, Patrick Halke, Stefan Hammes, Guillaume Helle, Harco de Hilster, Cord Hockemeyer, Markus 
Holzem, Olaf Klein, Leif Jensen, Bart Jourquin, Guilhem Lavaux, Jan Lessner, Nicholas Liebmann, Torsten Liermann, Per Lindqvist, Thomas Runge, Tatu
M\"{a}nnist\"{o}, Scott Maxwell, Thomas Myers, Oliver Niedung, Stefan Neis, Hernan Otero, Ian Perrigo, Timothy Peters, Giordano Pezzoli, Harri Pasanen, Thomaso Paoletti, 
Garrett Potts, Marcel Rasche, Robert Roebling, Dino Scaringella, Jobst Schmalenbach, Arthur Seaton, Paul Shirley, Vaclav Slavik, Stein Somers, Petr Smilauer, Neil Smith, 
Kari Syst\"{a}, Arthur Tetzlaff-Deas, Jonathan Tonberg, Jyrki Tuomi, David Webster, Janos Vegh, Andrea Venturoli, Vadim Zeitlin, Xiaokun Zhu, Edward Zimmermann.

`Graphplace', the basis for the wxGraphLayout library, is copyright Dr. Jos
T.J. van Eijndhoven of Eindhoven University of Technology. The code has
been used in wxGraphLayout with his permission.

We also acknowledge the author of XFIG, the excellent Unix drawing tool,
from the source of which we have borrowed some spline drawing code.
His copyright is included below.

{\it XFig2.1 is copyright (c) 1985 by Supoj Sutanthavibul. Permission to
use, copy, modify, distribute, and sell this software and its
documentation for any purpose is hereby granted without fee, provided
that the above copyright notice appear in all copies and that both that
copyright notice and this permission notice appear in supporting
documentation, and that the name of M.I.T. not be used in advertising or
publicity pertaining to distribution of the software without specific,
written prior permission.  M.I.T. makes no representations about the
suitability of this software for any purpose.  It is provided ``as is''
without express or implied warranty.}

\chapter{Multi-platform development with wxWindows}\label{multiplat}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter describes the practical details of using wxWindows. Please
see the file install.txt for up-to-date installation instructions, and
changes.txt for differences between versions.

\section{Include files}

The main include file is {\tt "wx/wx.h"}; this includes the most commonly
used modules of wxWindows.

To save on compilation time, include only those header files relevant to the
source file. If you are using precompiled headers, you should include
the following section before any other includes:

\begin{verbatim}
// For compilers that support precompilation, includes "wx.h".
#include <wx/wxprec.h>

#ifdef __BORLANDC__
#pragma hdrstop
#endif

#ifndef WX_PRECOMP
// Include your minimal set of headers here, or wx.h
#include <wx/wx.h>
#endif

... now your other include files ...
\end{verbatim}

The file {\tt "wx/wxprec.h"} includes {\tt "wx/wx.h"}. Although this incantation
may seem quirky, it is in fact the end result of a lot of experimentation,
and several Windows compilers to use precompilation (those tested are Microsoft Visual C++, Borland C++
and Watcom C++).

Borland precompilation is largely automatic. Visual C++ requires specification of {\tt "wx/wxprec.h"} as
the file to use for precompilation. Watcom C++ is automatic apart from the specification of
the .pch file. Watcom C++ is strange in requiring the precompiled header to be used only for
object files compiled in the same directory as that in which the precompiled header was created.
Therefore, the wxWindows Watcom C++ makefiles go through hoops deleting and recreating
a single precompiled header file for each module, thus preventing an accumulation of many
multi-megabyte .pch files.

\section{Libraries}

The GTK and Motif ports of wxWindow can create either a static library or a shared
library on most Unix or Unix-like systems. The static library is called libwx\_gtk.a
and libwx\_motif.a whereas the name of the shared library is dependent on the
system it is created on and the version you are using. The library name for the
GTK version of wxWindows 2.2 on Linux and Solaris will be libwx\_gtk-2.2.so.0.0.0,
on HP-UX, it will be libwx\_gtk-2.2.sl, on AIX just libwx\_gtk.a etc.

Under Windows, use the library wx.lib (release) or wxd.lib (debug) for stand-alone Windows
applications, or wxdll.lib (wxdlld.lib) for creating DLLs.

\section{Configuration}

Options are configurable in the file
\rtfsp{\tt "wx/XXX/setup.h"} where XXX is the required platform (such as msw, motif, gtk, mac). Some 
settings are a matter of taste, some help with platform-specific problems, and
others can be set to minimize the size of the library. Please see the setup.h file
and {\tt install.txt} files for details on configuration.

Under Unix (GTK and Motif) the corresponding setup.h files are generated automatically
when configuring the wxWindows using the "configure" script. When using the RPM packages
for installing wxWindows on Linux, a correct setup.h is shipped in the package and
this must not be changed.

\section{Makefiles}

At the moment there is no attempt to make Unix makefiles and
PC makefiles compatible, i.e. one makefile is required for
each environment. The Unix ports use a sophisticated system based
on the GNU autoconf tool and this system will create the
makefiles as required on the respective platform. Although the
makefiles are not identical in Windows, Mac and Unix, care has
been taken to make them relatively similar so that moving from
one platform to another will be painless.

Sample makefiles for Unix (suffix .unx), MS C++ (suffix .DOS and .NT), Borland
C++ (.BCC and .B32) and Symantec C++ (.SC) are included for the library, demos
and utilities.

The controlling makefile for wxWindows is in the MS-Windows
directory {\tt src/msw} for the different Windows compiler and
in the build directory when using the Unix ports. The build
directory can be chosen by the user. It is the directory in
which the "configure" script is run. This can be the normal
base directory (by running {\tt ./configure} there) or any other
directory (e.g. {\tt ../configure} after creating a build-directory
in the directory level above the base directory).

Please see the platform-specific {\tt install.txt} file for further details.

\section{Windows-specific files}

wxWindows application compilation under MS Windows requires at least two
extra files, resource and module definition files.

\subsection{Resource file}\label{resources}

The least that must be defined in the Windows resource file (extension RC)
is the following statement:

\begin{verbatim}
rcinclude "wx/msw/wx.rc"
\end{verbatim}

which includes essential internal wxWindows definitions.  The resource script
may also contain references to icons, cursors, etc., for example:

\begin{verbatim}
wxicon icon wx.ico
\end{verbatim}

The icon can then be referenced by name when creating a frame icon. See
the MS Windows SDK documentation.

\normalbox{Note: include wx.rc {\it after} any ICON statements
so programs that search your executable for icons (such
as the Program Manager) find your application icon first.}

\subsection{Module definition file}

A module definition file (extension DEF) is required for 16-bit applications, and
looks like the following:

\begin{verbatim}
NAME         Hello
DESCRIPTION  'Hello'
EXETYPE      WINDOWS
STUB         'WINSTUB.EXE'
CODE         PRELOAD MOVEABLE DISCARDABLE
DATA         PRELOAD MOVEABLE MULTIPLE
HEAPSIZE     1024
STACKSIZE    8192
\end{verbatim}

The only lines which will usually have to be changed per application are
NAME and DESCRIPTION.

\section{Allocating and deleting wxWindows objects}

In general, classes derived from wxWindow must dynamically allocated
with {\it new} and deleted with {\it delete}. If you delete a window,
all of its children and descendants will be automatically deleted,
so you don't need to delete these descendants explicitly.

When deleting a frame or dialog, use {\bf Destroy} rather than {\bf delete} so
that the wxWindows delayed deletion can take effect. This waits until idle time
(when all messages have been processed) to actually delete the window, to avoid
problems associated with the GUI sending events to deleted windows.

Don't create a window on the stack, because this will interfere
with delayed deletion.

If you decide to allocate a C++ array of objects (such as wxBitmap) that may
be cleaned up by wxWindows, make sure you delete the array explicitly
before wxWindows has a chance to do so on exit, since calling {\it delete} on
array members will cause memory problems.

wxColour can be created statically: it is not automatically cleaned
up and is unlikely to be shared between other objects; it is lightweight
enough for copies to be made.

Beware of deleting objects such as a wxPen or wxBitmap if they are still in use.
Windows is particularly sensitive to this: so make sure you
make calls like wxDC::SetPen(wxNullPen) or wxDC::SelectObject(wxNullBitmap) before deleting
a drawing object that may be in use. Code that doesn't do this will probably work
fine on some platforms, and then fail under Windows.

\section{Architecture dependency}

A problem which sometimes arises from writing multi-platform programs is that
the basic C types are not defined the same on all platforms. This holds true
for both the length in bits of the standard types (such as int and long) as 
well as their byte order, which might be little endian (typically
on Intel computers) or big endian (typically on some Unix workstations). wxWindows
defines types and macros that make it easy to write architecture independent
code. The types are:

wxInt32, wxInt16, wxInt8, wxUint32, wxUint16 = wxWord, wxUint8 = wxByte

where wxInt32 stands for a 32-bit signed integer type etc. You can also check
which architecture the program is compiled on using the wxBYTE\_ORDER define
which is either wxBIG\_ENDIAN or wxLITTLE\_ENDIAN (in the future maybe wxPDP\_ENDIAN
as well).

The macros handling bit-swapping with respect to the applications endianness
are described in the \helpref{Byte order macros}{byteordermacros} section.

\section{Conditional compilation}

One of the purposes of wxWindows is to reduce the need for conditional
compilation in source code, which can be messy and confusing to follow.
However, sometimes it is necessary to incorporate platform-specific
features (such as metafile use under MS Windows). The symbols
listed in the file {\tt symbols.txt} may be used for this purpose,
along with any user-supplied ones.

\section{C++ issues}

The following documents some miscellaneous C++ issues.

\subsection{Templates}

wxWindows does not use templates since it is a notoriously unportable feature.

\subsection{RTTI}

wxWindows does not use run-time type information since wxWindows provides
its own run-time type information system, implemented using macros.

\subsection{Type of NULL}

Some compilers (e.g. the native IRIX cc) define NULL to be 0L so that
no conversion to pointers is allowed. Because of that, all these
occurrences of NULL in the GTK port use an explicit conversion such 
as

{\small
\begin{verbatim}
  wxWindow *my_window = (wxWindow*) NULL;
\end{verbatim}
}

It is recommended to adhere to this in all code using wxWindows as
this make the code (a bit) more portable.

\subsection{Precompiled headers}

Some compilers, such as Borland C++ and Microsoft C++, support
precompiled headers. This can save a great deal of compiling time. The
recommended approach is to precompile {\tt "wx.h"}, using this
precompiled header for compiling both wxWindows itself and any
wxWindows applications. For Windows compilers, two dummy source files
are provided (one for normal applications and one for creating DLLs)
to allow initial creation of the precompiled header.

However, there are several downsides to using precompiled headers. One
is that to take advantage of the facility, you often need to include
more header files than would normally be the case. This means that
changing a header file will cause more recompilations (in the case of
wxWindows, everything needs to be recompiled since everything includes {\tt "wx.h"}!)

A related problem is that for compilers that don't have precompiled
headers, including a lot of header files slows down compilation
considerably. For this reason, you will find (in the common
X and Windows parts of the library) conditional
compilation that under Unix, includes a minimal set of headers;
and when using Visual C++, includes {\tt wx.h}. This should help provide
the optimal compilation for each compiler, although it is
biased towards the precompiled headers facility available
in Microsoft C++.

\section{File handling}

When building an application which may be used under different
environments, one difficulty is coping with documents which may be
moved to different directories on other machines. Saving a file which
has pointers to full pathnames is going to be inherently unportable. One
approach is to store filenames on their own, with no directory
information.  The application searches through a number of locally
defined directories to find the file. To support this, the class {\bf
wxPathList} makes adding directories and searching for files easy, and
the global function {\bf wxFileNameFromPath} allows the application to
strip off the filename from the path if the filename must be stored.
This has undesirable ramifications for people who have documents of the
same name in different directories.

As regards the limitations of DOS 8+3 single-case filenames versus
unrestricted Unix filenames, the best solution is to use DOS filenames
for your application, and also for document filenames {\it if} the user
is likely to be switching platforms regularly. Obviously this latter
choice is up to the application user to decide.  Some programs (such as
YACC and LEX) generate filenames incompatible with DOS; the best
solution here is to have your Unix makefile rename the generated files
to something more compatible before transferring the source to DOS.
Transferring DOS files to Unix is no problem, of course, apart from EOL
conversion for which there should be a utility available (such as
dos2unix).

See also the File Functions section of the reference manual for
descriptions of miscellaneous file handling functions.

\chapter{Utilities and libraries supplied with wxWindows}\label{utilities}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

In addition to the core wxWindows library, a number of further
libraries and utilities are supplied with each distribution.

Some are under the 'contrib' hierarchy which mirrors the
structure of the main wxWindows hierarchy. See also the 'utils'
hierarchy. The first place to look for documentation about
these tools and libraries is under the wxWindows 'docs' hierarchy,
for example {\tt docs/htmlhelp/fl.chm}.

For other user-contributed packages, please see the Contributions page
on the \urlref{wxWindows Web site}{http://www.wxwindows.org}.

\begin{description}\itemsep=0pt
\item[{\bf Helpview}]
Helpview is a program for displaying wxWindows HTML
Help files. In many cases, you may wish to use the wxWindows HTML
Help classes from within your application, but this provides a
handy stand-alone viewer. See \helpref{wxHTML Notes}{wxhtml} for more details.
You can find it in {\tt samples/html/helpview}.

\item[{\bf Tex2RTF}]
Supplied with wxWindows is a utility called Tex2RTF for converting\rtfsp
\LaTeX\ manuals HTML, MS HTML Help, wxHTML Help, RTF, and Windows
Help RTF formats. Tex2RTF is used for the wxWindows manuals and can be used independently
by authors wishing to create on-line and printed manuals from the same\rtfsp
\LaTeX\ source. Please see the separate documentation for Tex2RTF.
You can find it under {\tt utils/tex2rtf}.

\item[{\bf Helpgen}]
Helpgen takes C++ header files and generates a Tex2RTF-compatible
documentation file for each class it finds, using comments as appropriate.
This is a good way to start a reference for a set of classes.

\item[{\bf Dialog Editor}]
Dialog Editor allows interactive construction of dialogs using
absolute positioning, producing WXR output files. This tool is generally deprecated
in favour of sizer-based tools. You can find Dialog Editor
in {\tt utils/dialoged}.

\item[{\bf XRC resource system}]
This is the sizer-aware replacement for the WXR resource system, and uses
XML-based resource specifications that can be generated by tools
such as \urlref{wxDesigner}{http://www.roebling.de} and XRC's own wxrcedit.
You can find this in {\tt contrib/src/xrc}, {\tt contrib/include/wx/xrc}, {\tt contrib/samples/xrc}, and {\tt contrib/utils/wxrcedit}.
For more information, see the \helpref{XML-based resource system overview}{xrcoverview}.

\item[{\bf Object Graphics Library}]
OGL defines an API for applications that need to display objects connected by lines.
The objects can be moved around and interacted with.
You can find this in {\tt contrib/src/ogl}, {\tt contrib/include/wx/ogl}, and {\tt contrib/samples/ogl}.

\item[{\bf Frame Layout library}]
FL provides sophisticated pane dragging and docking facilities.
You can find this in {\tt contrib/src/fl}, {\tt contrib/include/wx/fl}, and {\tt contrib/samples/fl}.

\item[{\bf Gizmos library}]
Gizmos is a collection of useful widgets and other classes. Classes include wxLEDNumberCtrl,
wxEditableListBox, wxMultiCellCanvas.
You can find this in {\tt contrib/src/fl}, {\tt contrib/include/wx/fl}, and {\tt contrib/samples/fl}.

\item[{\bf Net library}]
Net is a collection of very simple mail and web related classes. Currently
there is only wxEmail, which makes it easy to send email messages via MAPI on Windows or sendmail on Unix.
You can find this in {\tt contrib/src/net} and {\tt contrib/include/wx/net}.

\item[{\bf Animate library}]
Animate allows you to load animated GIFs and play them on a window. The library can be extended
to use other animation formats.
You can find this in {\tt contrib/src/animate}, {\tt contrib/include/wx/animate}, and {\tt contrib/samples/animate}.

\item[{\bf Canvas library}]
Canvas supports high-level, double-buffered drawing operations with transformations.
You can find this in {\tt contrib/src/canvas}, {\tt contrib/include/wx/canvas}, and {\tt contrib/samples/canvas}.

\item[{\bf MMedia library}]
Mmedia supports a variety of multimedia functionality. The status of this library is currently unclear.
You can find this in {\tt contrib/src/mmedia}, {\tt contrib/include/wx/mmedia}, and {\tt contrib/samples/mmedia}.

\item[{\bf Styled Text Control library}]
STC is a wrapper around Scintilla, a syntax-highlighting text editor.
You can find this in {\tt contrib/src/stc}, {\tt contrib/include/wx/stc}, and {\tt contrib/samples/stc}.

\item[{\bf Plot}]
Plot is a simple curve plotting library.
You can find this in {\tt contrib/src/plot}, {\tt contrib/include/wx/plot}, and {\tt contrib/samples/plot}.
\end{description}

\chapter{Programming strategies}\label{strategies}
\setheader{{\it CHAPTER \thechapter}}{}{}{}{}{{\it CHAPTER \thechapter}}%
\setfooter{\thepage}{}{}{}{}{\thepage}%

This chapter is intended to list strategies that may be useful when
writing and debugging wxWindows programs. If you have any good tips,
please submit them for inclusion here.

\section{Strategies for reducing programming errors}

\subsection{Use ASSERT}

Although I haven't done this myself within wxWindows, it is good
practice to use ASSERT statements liberally, that check for conditions that
should or should not hold, and print out appropriate error messages.
These can be compiled out of a non-debugging version of wxWindows
and your application. Using ASSERT is an example of `defensive programming':
it can alert you to problems later on.

\subsection{Use wxString in preference to character arrays}

Using wxString can be much safer and more convenient than using char *.
Again, I haven't practiced what I'm preaching, but I'm now trying to use
wxString wherever possible. You can reduce the possibility of memory
leaks substantially, and it is much more convenient to use the overloaded
operators than functions such as strcmp. wxString won't add a significant
overhead to your program; the overhead is compensated for by easier
manipulation (which means less code).

The same goes for other data types: use classes wherever possible.

\section{Strategies for portability}

\subsection{Use relative positioning or constraints}

Don't use absolute panel item positioning if you can avoid it. Different GUIs have
very differently sized panel items. Consider using the constraint system, although this
can be complex to program.

Alternatively, you could use alternative .wrc (wxWindows resource files) on different
platforms, with slightly different dimensions in each. Or space your panel items out
to avoid problems.

\subsection{Use wxWindows resource files}

Use .wrc (wxWindows resource files) where possible, because they can be easily changed
independently of source code. Bitmap resources can be set up to load different
kinds of bitmap depending on platform (see the section on resource files).

\section{Strategies for debugging}\label{debugstrategies}

\subsection{Positive thinking}

It is common to blow up the problem in one's imagination, so that it seems to threaten
weeks, months or even years of work. The problem you face may seem insurmountable:
but almost never is. Once you have been programming for some time, you will be able
to remember similar incidents that threw you into the depths of despair. But
remember, you always solved the problem, somehow!

Perseverance is often the key, even though a seemingly trivial problem
can take an apparently inordinate amount of time to solve. In the end,
you will probably wonder why you worried so much. That's not to say it
isn't painful at the time. Try not to worry -- there are many more important
things in life.

\subsection{Simplify the problem}

Reduce the code exhibiting the problem to the smallest program possible
that exhibits the problem. If it is not possible to reduce a large and
complex program to a very small program, then try to ensure your code
doesn't hide the problem (you may have attempted to minimize the problem
in some way: but now you want to expose it).

With luck, you can add a small amount of code that causes the program
to go from functioning to non-functioning state. This should give a clue
to the problem. In some cases though, such as memory leaks or wrong
deallocation, this can still give totally spurious results!

\subsection{Use a debugger}

This sounds like facetious advice, but it is surprising how often people
don't use a debugger. Often it is an overhead to install or learn how to
use a debugger, but it really is essential for anything but the most
trivial programs.

\subsection{Use logging functions}

There is a variety of logging functions that you can use in your program:
see \helpref{Logging functions}{logfunctions}.

Using tracing statements may be more convenient than using the debugger
in some circumstances (such as when your debugger doesn't support a lot
of debugging code, or you wish to print a bunch of variables).

\subsection{Use the wxWindows debugging facilities}

You can use wxDebugContext to check for
memory leaks and corrupt memory: in fact in debugging mode, wxWindows will
automatically check for memory leaks at the end of the program if wxWindows is suitably
configured. Depending on the operating system and compiler, more or less
specific information about the problem will be logged.

You should also use \helpref{debug macros}{debugmacros} as part of a `defensive programming' strategy,
scattering wxASSERTs liberally to test for problems in your code as early as possible. Forward thinking
will save a surprising amount of time in the long run.

See the \helpref{debugging overview}{debuggingoverview} for further information.

\subsection{Check Windows debug messages}

Under Windows, it is worth running your program with 
\urlref{DbgView}{http://www.sysinternals.com} running or
some other program that shows Windows-generated debug messages. It is
possible it will show invalid handles being used. You may have fun seeing
what commercial programs cause these normally hidden errors! Microsoft
recommend using the debugging version of Windows, which shows up even
more problems. However, I doubt it is worth the hassle for most
applications. wxWindows is designed to minimize the possibility of such
errors, but they can still happen occasionally, slipping through unnoticed
because they are not severe enough to cause a crash.

\subsection{Genetic mutation}

If we had sophisticated genetic algorithm tools that could be applied
to programming, we could use them. Until then, a common -- if rather irrational --
technique is to just make arbitrary changes to the code until something
different happens. You may have an intuition why a change will make a difference;
otherwise, just try altering the order of code, comment lines out, anything
to get over an impasse. Obviously, this is usually a last resort.

