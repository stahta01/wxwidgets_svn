\section{\class{wxScrolledWindow}}\label{wxscrolledwindow}

The wxScrolledWindow class manages scrolling for its client area, transforming
the coordinates according to the scrollbar positions, and setting the
scroll positions, thumb sizes and ranges according to the area in view.

As with all windows, an application can draw onto a wxScrolledWindow using a \helpref{device context}{dcoverview}.

You have the option of handling the \helpref{OnPaint}{wxscrolledwindowonpaint} handler
or overriding the \helpref{OnDraw}{wxscrolledwindowondraw} function, which is passed
a pre-scrolled device context (prepared by \helpref{PrepareDC}{wxscrolledwindowpreparedc}).

If you don't wish to calculate your own scrolling, you must call PrepareDC when not drawing from
within OnDraw, to set the device origin for the device context according to the current
scroll position.

\wxheading{Derived from}

\helpref{wxWindow}{wxwindow}\\
\helpref{wxEvtHandler}{wxevthandler}\\
\helpref{wxObject}{wxobject}

\wxheading{Include files}

<wx/scrolwin.h>

\wxheading{Window styles}

\twocolwidtha{5cm}
\begin{twocollist}\itemsep=0pt
\twocolitem{\windowstyle{wxRETAINED}}{Uses a backing pixmap to speed refreshes. Motif only.}
\end{twocollist}

See also \helpref{window styles overview}{windowstyles}.

\wxheading{Remarks}

Use wxScrolledWindow for applications where the user scrolls by a fixed amount, and
where a `page' can be interpreted to be the current visible portion of the window. For
more sophisticated applications, use the wxScrolledWindow implementation as a guide
to build your own scroll behaviour.

\wxheading{See also}

\helpref{wxScrollBar}{wxscrollbar}, \helpref{wxClientDC}{wxclientdc}, \helpref{wxPaintDC}{wxpaintdc}

\latexignore{\rtfignore{\wxheading{Members}}}

\membersection{wxScrolledWindow::wxScrolledWindow}\label{wxscrolledwindowconstr}

\func{}{wxScrolledWindow}{\void}

Default constructor.

\func{}{wxScrolledWindow}{\param{wxWindow*}{ parent}, \param{wxWindowID }{id = -1},\rtfsp
\param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = wxHSCROLL \pipe wxVSCROLL}, \param{const wxString\& }{name = ``scrolledWindow"}}

Constructor.

\wxheading{Parameters}

\docparam{parent}{Parent window.}

\docparam{id}{Window identifier. A value of -1 indicates a default value.}

\docparam{pos}{Window position. If a position of (-1, -1) is specified then a default position
is chosen.}

\docparam{size}{Window size. If a size of (-1, -1) is specified then the window is sized
appropriately.}

\docparam{style}{Window style. See \helpref{wxScrolledWindow}{wxscrolledwindow}.}

\docparam{name}{Window name.}

\wxheading{Remarks}

The window is initially created without visible scrollbars.
Call \helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars} to
specify how big the virtual window size should be.

\membersection{wxScrolledWindow::\destruct{wxScrolledWindow}}

\func{}{\destruct{wxScrolledWindow}}{\void}

Destructor.

\membersection{wxScrolledWindow::CalcScrolledPosition}\label{wxscrolledwindowcalcscrolledposition}

\constfunc{void}{CalcScrolledPosition}{
   \param{int }{x},
   \param{int }{y},
   \param{int *}{xx}
   \param{int *}{yy}}

Translates the logical coordinates to the device ones. For example, if a window is
scrolled 10 pixels to the bottom, the device coordinates of the origin are (0, 0)
(as always), but the logical coordinates are (0, 10) and so the call to
CalcScrolledPosition(0, 0, \&xx, \&yy) will return 10 in yy.

\wxheading{See also}

\helpref{CalcUnscrolledPosition}{wxscrolledwindowcalcunscrolledposition}

\membersection{wxScrolledWindow::CalcUnscrolledPosition}\label{wxscrolledwindowcalcunscrolledposition}

\constfunc{void}{CalcUnscrolledPosition}{
   \param{int }{x},
   \param{int }{y},
   \param{int *}{xx}
   \param{int *}{yy}}

Translates the device coordinates to the logical ones. For example, if a window is
scrolled 10 pixels to the bottom, the device coordinates of the origin are (0, 0)
(as always), but the logical coordinates are (0, 10) and so the call to
CalcUnscrolledPosition(0, 10, \&xx, \&yy) will return 0 in yy.

\wxheading{See also}

\helpref{CalcScrolledPosition}{wxscrolledwindowcalcscrolledposition}

\membersection{wxScrolledWindow::Create}\label{wxscrolledwindowcreate}

\func{bool}{Create}{\param{wxWindow*}{ parent}, \param{wxWindowID }{id = -1},\rtfsp
\param{const wxPoint\& }{pos = wxDefaultPosition}, \param{const wxSize\& }{size = wxDefaultSize},\rtfsp
\param{long}{ style = wxHSCROLL \pipe wxVSCROLL}, \param{const wxString\& }{name = ``scrolledWindow"}}

Creates the window for two-step construction. Derived classes
should call or replace this function. See \helpref{wxScrolledWindow::wxScrolledWindow}{wxscrolledwindowconstr}\rtfsp
for details.

\membersection{wxScrolledWindow::EnableScrolling}\label{wxscrolledwindowenablescrolling}

\func{void}{EnableScrolling}{\param{const bool}{ xScrolling}, \param{const bool}{ yScrolling}}

Enable or disable physical scrolling in the given direction. Physical
scrolling is the physical transfer of bits up or down the
screen when a scroll event occurs. If the application scrolls by a
variable amount (e.g. if there are different font sizes) then physical
scrolling will not work, and you should switch it off.

\wxheading{Parameters}

\docparam{xScrolling}{If TRUE, enables physical scrolling in the x direction.}

\docparam{yScrolling}{If TRUE, enables physical scrolling in the y direction.}

\wxheading{Remarks}

Physical scrolling may not be available on all platforms. Where it is available, it is enabled
by default.

\membersection{wxScrolledWindow::GetScrollPixelsPerUnit}\label{wxscrolledwindowgetscrollpixelsperunit}

\constfunc{void}{GetScrollPixelsPerUnit}{\param{int* }{xUnit}, \param{int* }{yUnit}}

Get the number of pixels per scroll unit (line), in each direction, as set
by \helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars}. A value of zero indicates no
scrolling in that direction.

\wxheading{Parameters}

\docparam{xUnit}{Receives the number of pixels per horizontal unit.}

\docparam{yUnit}{Receives the number of pixels per vertical unit.}

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetVirtualSize}{wxscrolledwindowgetvirtualsize}

\membersection{wxScrolledWindow::GetVirtualSize}\label{wxscrolledwindowgetvirtualsize}

\constfunc{void}{GetVirtualSize}{\param{int* }{x}, \param{int* }{y}}

Gets the size in device units of the scrollable window area (as
opposed to the client size, which is the area of the window currently
visible).

\wxheading{Parameters}

\docparam{x}{Receives the length of the scrollable window, in pixels.}

\docparam{y}{Receives the height of the scrollable window, in pixels.}

\wxheading{Remarks}

Use \helpref{wxDC::DeviceToLogicalX}{wxdcdevicetologicalx} and \helpref{wxDC::DeviceToLogicalY}{wxdcdevicetologicaly}\rtfsp
to translate these units to logical units.

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetScrollPixelsPerUnit}{wxscrolledwindowgetscrollpixelsperunit}

\membersection{wxScrolledWindow::IsRetained}\label{wxscrolledwindowisretained}

\constfunc{bool}{IsRetained}{\void}

Motif only: TRUE if the window has a backing bitmap.

\membersection{wxScrolledWindow::PrepareDC}\label{wxscrolledwindowpreparedc}

\func{void}{PrepareDC}{\param{wxDC\& }{dc}}

Call this function to prepare the device context for drawing a scrolled image. It
sets the device origin according to the current scroll position.

PrepareDC is called automatically within the default \helpref{wxScrolledWindow::OnPaint}{wxscrolledwindowonpaint} event
handler, so your \helpref{wxScrolledWindow::OnDraw}{wxscrolledwindowondraw} override
will be passed a 'pre-scrolled' device context. However, if you wish to draw from
outside of OnDraw (via OnPaint), or you wish to implement OnPaint yourself, you must
call this function yourself. For example:

\begin{verbatim}
void MyWindow::OnEvent(wxMouseEvent& event)
{
  wxClientDC dc(this);
  PrepareDC(dc);

  dc.SetPen(*wxBLACK_PEN);
  float x, y;
  event.Position(&x, &y);
  if (xpos > -1 && ypos > -1 && event.Dragging())
  {
    dc.DrawLine(xpos, ypos, x, y);
  }
  xpos = x;
  ypos = y;
}
\end{verbatim}

\membersection{wxScrolledWindow::OnDraw}\label{wxscrolledwindowondraw}

\func{virtual void}{OnDraw}{\param{wxDC\& }{dc}}

Called by the default paint event handler to allow the application to define
painting behaviour without having to worry about calling 
\helpref{wxScrolledWindow::PrepareDC}{wxscrolledwindowpreparedc}.

Instead of overriding this function you may also just process the paint event
in the derived class as usual, but then you will have to call PrepareDC()
yourself.

\membersection{wxScrolledWindow::Scroll}\label{wxscrolledwindowscroll}

\func{void}{Scroll}{\param{int}{ x}, \param{int}{ y}}

Scrolls a window so the view start is at the given point.

\wxheading{Parameters}

\docparam{x}{The x position to scroll to, in scroll units.}

\docparam{y}{The y position to scroll to, in scroll units.}

\wxheading{Remarks}

The positions are in scroll units, not pixels, so to convert to pixels you
will have to multiply by the number of pixels per scroll increment.
If either parameter is -1, that position will be ignored (no change in
that direction).

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars},\rtfsp
\helpref{wxScrolledWindow::GetScrollPixelsPerUnit}{wxscrolledwindowgetscrollpixelsperunit}

\membersection{wxScrolledWindow::SetScrollbars}\label{wxscrolledwindowsetscrollbars}

\func{void}{SetScrollbars}{\param{int}{ pixelsPerUnitX}, \param{int}{ pixelsPerUnitY},\rtfsp
\param{int}{ noUnitsX}, \param{int}{ noUnitsY},\rtfsp
\param{int }{xPos = 0}, \param{int}{ yPos = 0}}

Sets up vertical and/or horizontal scrollbars.

\wxheading{Parameters}

\docparam{pixelsPerUnitX}{Pixels per scroll unit in the horizontal direction.}

\docparam{pixelsPerUnitY}{Pixels per scroll unit in the vertical direction.}

\docparam{noUnitsX}{Number of units in the horizontal direction.}

\docparam{noUnitsY}{Number of units in the vertical direction.}

\docparam{xPos}{Position to initialize the scrollbars in the horizontal direction, in scroll units.}

\docparam{yPos}{Position to initialize the scrollbars in the vertical direction, in scroll units.}

\wxheading{Remarks}

The first pair of parameters give the number of pixels per `scroll step', i.e. amount
moved when the up or down scroll arrows are pressed.
The second pair gives the length of scrollbar in scroll steps, which sets the size of the virtual
window.

{\it xPos} and {\it yPos} optionally specify a position to scroll to immediately.

For example, the following gives a window horizontal and vertical
scrollbars with 20 pixels per scroll step, and a size of 50 steps (1000
pixels) in each direction.

\begin{verbatim}
  window->SetScrollbars(20, 20, 50, 50);
\end{verbatim}

wxScrolledWindow manages the page size itself,
using the current client window size as the page size.

Note that for more sophisticated scrolling applications, for example where
scroll steps may be variable according to the position in the document, it will be
necessary to derive a new class from wxWindow, overriding {\bf OnSize} and
adjusting the scrollbars appropriately.

\membersection{wxScrolledWindow::ViewStart}\label{wxscrolledwindowviewstart}

\constfunc{void}{ViewStart}{\param{int* }{x}, \param{int* }{ y}}

Get the position at which the visible portion of the window starts.

\wxheading{Parameters}

\docparam{x}{Receives the first visible x position in scroll units.}

\docparam{y}{Receives the first visible y position in scroll units.}

\wxheading{Remarks}

If either of the scrollbars is not at the home position, {\it x} and/or
\rtfsp{\it y} will be greater than zero.  Combined with \helpref{wxWindow::GetClientSize}{wxwindowgetclientsize},
the application can use this function to efficiently redraw only the
visible portion of the window.  The positions are in logical scroll
units, not pixels, so to convert to pixels you will have to multiply
by the number of pixels per scroll increment.

\wxheading{See also}

\helpref{wxScrolledWindow::SetScrollbars}{wxscrolledwindowsetscrollbars}

