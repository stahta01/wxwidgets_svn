Index: Source/Modules/python.cxx
===================================================================
RCS file: /cvsroot/SWIG/Source/Modules/python.cxx,v
retrieving revision 1.39
diff -u -4 -r1.39 python.cxx
--- Source/Modules/python.cxx	22 Jan 2004 22:42:17 -0000	1.39
+++ Source/Modules/python.cxx	22 Jan 2004 23:39:03 -0000
@@ -50,8 +50,17 @@
 static  int       have_constructor;
 static  int       have_repr;
 static  String   *real_classname;
 
+/* flags for the make_autodoc function */
+enum autodoc_t {
+  AUTODOC_CLASS,
+  AUTODOC_CTOR,
+  AUTODOC_DTOR,
+  AUTODOC_STATICFUNC,
+  AUTODOC_FUNC
+};
+
 static const char *usage = (char *)"\
 Python Options (available with -python)\n\
      -ldflags        - Print runtime libraries to link with\n\
      -globals <name> - Set <name> used to access C global variable [default: 'cvar']\n\
@@ -417,17 +426,23 @@
    *    functions.
    * ------------------------------------------------------------ */
 
   void emitFunctionShadowHelper(Node *n, File *f_dest, String *name, int kw) {
-    if ( ! have_addtofunc(n) ) {
-      /* If there is no addtofunc directive then just assign from the extension module */
+    if ( ! have_addtofunc(n) && ! have_docstring(n) ) {
+      /* If there is no addtofunc or docstring directive then just assign from the extension module */
       Printv(f_dest, "\n", name, " = ", module, ".", name, "\n", NIL);
     } else {
       /* Otherwise make a wrapper function to insert the code into */
       Printv(f_dest, "\ndef ", name, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-      Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
-      Printv(f_dest, tab4, addtofunc(n), "\n", NIL);
-      Printv(f_dest, tab4, "return val\n", NIL);
+      if ( have_docstring(n) )
+        Printv(f_dest, tab4, docstring(n, AUTODOC_FUNC, tab4), "\n", NIL);
+      if ( have_addtofunc(n) ) {
+        Printv(f_dest, tab4, "val = ", funcCallHelper(name, kw), "\n", NIL);
+        Printv(f_dest, tab4, addtofunc(n), "\n", NIL);
+        Printv(f_dest, tab4, "return val\n", NIL);
+      } else {
+        Printv(f_dest, tab4, "return ", funcCallHelper(name, kw), "\n", NIL);
+      }        
     }
   }
 
 
@@ -441,8 +456,256 @@
   }
 
 
   /* ------------------------------------------------------------
+   * have_docstring()
+   *    Check if there is a docstring directive and it has text,
+   *    or there is an autodoc flag set
+   * ------------------------------------------------------------ */
+
+  bool have_docstring(Node *n) {
+    String* str = Getattr(n, "feature:docstring");
+    return (str != NULL && Len(str) > 0) ||
+        (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+  }
+  
+  /* ------------------------------------------------------------
+   * docstring()
+   *    Get the docstring text, stripping off {} if neccessary,
+   *    and enclose in triple double quotes.  If autodoc is also
+   *    set then it will build a combined docstring.
+   * ------------------------------------------------------------ */
+
+  String *docstring(Node *n, autodoc_t ad_type, const String* indent) {
+    String* str = Getattr(n, "feature:docstring");
+    bool have_ds = (str != NULL && Len(str) > 0);
+    bool have_auto = (Getattr(n,"feature:autodoc") && !Getattr(n, "feature:noautodoc"));
+    char* triple_double = "\"\"\"";
+    String* autodoc = NULL;
+    String* doc = NULL;
+
+    if ( have_ds ) {
+      char* t = Char(str);
+      if (*t == '{') {
+        Delitem(str ,0);
+        Delitem(str,DOH_END);
+      }
+    }
+
+    if ( have_auto ) {
+      autodoc = make_autodoc(n, ad_type);
+      have_auto = (autodoc != NULL && Len(autodoc) > 0);
+    }
+    
+//     if ( have_auto && have_ds )
+//       doc = NewStringf("%s%s\n\n%s%s", triple_double, autodoc, str, triple_double);
+//     else if ( !have_auto && have_ds )
+//       doc = NewStringf("%s%s%s", triple_double, str, triple_double);
+//     else
+//       doc = NewStringf("%s%s%s", triple_double, autodoc, triple_double);
+
+    
+    // If there is more than one line then make docstrings like this:
+    //
+    //      """
+    //      This is line1
+    //      And here is line2 followed by the rest of them
+    //      """
+    //
+    // otherwise, put it all on a single line
+    //
+    if ( have_auto && have_ds ) {       // Both autodoc and docstring are present
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent), "\n",
+                  pythoncode(str, indent), 
+                  indent, triple_double, NIL);
+    }
+    else if ( !have_auto && have_ds ) { // only docstring
+      if (Strchr(str, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, str, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(str, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else if ( have_auto && !have_ds ) { // only autodoc
+      if (Strchr(autodoc, '\n') == NULL) {
+        doc = NewStringf("%s%s%s", triple_double, autodoc, triple_double);
+      }
+      else {
+      doc = NewString("");
+      Printv(doc, triple_double, "\n",
+                  pythoncode(autodoc, indent),
+                  indent, triple_double, NIL);
+      }
+    }
+    else
+      doc = NewString("");
+
+    // Save the generated strings in the parse tree in case they are used later
+    // by post processing tools
+    Setattr(n, "python:docstring", doc);
+    Setattr(n, "python:autodoc", autodoc);
+    return doc;
+  }
+
+
+  /* ------------------------------------------------------------
+   * make_autodoc()
+   *    Build a docstring for the node, using parameter and other
+   *    info in the parse tree.  If the value of the autodoc
+   *    attribute is "0" then do not include parameter types, if
+   *    it is "1" (the default) then do.  If it has some other
+   *    value then assume it is supplied by the extension writer
+   *    and use it directly.
+   * ------------------------------------------------------------ */
+
+  String* make_autodoc(Node *n, autodoc_t ad_type) {
+
+    if (ad_type == AUTODOC_CLASS)
+      return NULL;  // No function call to document in this case
+
+    // If the function is overloaded then this funciton is called
+    // for the last one.  Rewind to the first so the docstrings are
+    // in order.
+    while ( Getattr(n, "sym:previousSibling") )
+      n = Getattr(n, "sym:previousSibling");
+    
+    String* doc  = NewString("");
+    while (n) {
+      bool showTypes = false;
+      bool skipAuto = false;
+      
+      // check how should the parameters be rendered?
+      String* autodoc = Getattr(n, "feature:autodoc");
+      if (Strcmp(autodoc, "0") == 0)
+        showTypes = false;
+      else if (Strcmp(autodoc, "1") == 0)
+        showTypes = true;
+      else {
+        // if not "0" or "1" then autodoc is already the string that should be used
+        Printf(doc, "%s", autodoc);
+        skipAuto = true;
+      }
+
+      if (!skipAuto) {
+        String*   symname = Getattr(n, "sym:name");
+        SwigType* type    = Getattr(n, "type");
+      
+        if (type) {
+          if (Strcmp(type, "void") == 0)
+            type = NULL;
+          else {
+            SwigType* qt = SwigType_typedef_resolve_all(type);
+            if (SwigType_isenum(qt))
+              type = NewString("int");
+            else {
+              type = SwigType_base(type);
+              Node* lookup = Swig_symbol_clookup(type, 0);
+              if (lookup)
+                type = Getattr(lookup, "sym:name");
+            }
+          }     
+        }
+        
+        switch ( ad_type ) {
+        case AUTODOC_CTOR:
+          if ( Strcmp(class_name, symname) == 0)
+            Printf(doc, "__init__(%s) -> %s", make_autodocParmList(n, showTypes), class_name);
+          else
+            Printf(doc, "%s(%s) -> %s", symname, make_autodocParmList(n, showTypes), class_name);
+          break;
+          
+        case AUTODOC_DTOR:
+          Printf(doc, "__del__()");
+          break;
+        
+        case AUTODOC_STATICFUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;
+                      
+        case AUTODOC_FUNC:
+          Printf(doc, "%s(%s)", symname, make_autodocParmList(n, showTypes));
+          if (type) Printf(doc, " -> %s", type);
+          break;            
+        }
+      }
+      
+      // if it's overloaded then get the next decl and loop around again
+      n = Getattr(n, "sym:nextSibling");
+      if (n)
+        Printf(doc, "\n");
+    }
+          
+    return doc;
+  }
+
+
+  String* make_autodocParmList(Node* n, bool showTypes) {
+    String*   doc = NewString(""); 
+    ParmList* plist = Getattr(n,"parms");
+    Parm*     p;
+    Node*     lookup;
+    int       lines = 0;
+    const int maxwidth = 50;
+    
+
+    for (p = plist; p; p = nextSibling(p)) {
+      String*   name =  Getattr(p, "name");
+      String*   value = Getattr(p, "value");
+
+      if ( Len(doc) ) {
+        // add a comma to the previous one if any
+        Printf(doc, ", ");
+
+        // Do we need to wrap a long line?
+        if ((Len(doc) - lines*maxwidth) > maxwidth) {
+          Printf(doc, "\n%s", tab4);
+          lines += 1;
+        }
+      }
+        
+      // Do the param type too?
+      if (showTypes) {
+        SwigType* type =  SwigType_base(Getattr(p, "type"));
+        SwigType* qt = SwigType_typedef_resolve_all(type);
+        if (SwigType_isenum(qt))
+          type = NewString("int");
+        else {
+          lookup = Swig_symbol_clookup(type, 0);
+          if (lookup)
+            type = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "%s ", type);
+      }
+
+      if (name)
+        Printf(doc, "%s", name);
+      else
+        Printf(doc, "??");
+
+      if (value) {
+        if (Strcmp(value, "NULL") == 0)
+          value = NewString("None");
+        else {
+          lookup = Swig_symbol_clookup(value, 0);
+          if (lookup)
+            value = Getattr(lookup, "sym:name");
+        }
+        Printf(doc, "=%s", value);
+      }
+    }
+    
+    return doc;
+  }
+  
+  
+  /* ------------------------------------------------------------
    * have_addtofunc()
    *    Check if there is a %addtofunc directive and it has text
    * ------------------------------------------------------------ */
 
@@ -1698,9 +1961,11 @@
 	  Printf(f_shadow, modern ? "(object)" : "(_object)");
 	}
       }
       Printf(f_shadow,":\n");
-
+      if ( Getattr(n, "feature:docstring") ) // don't use have_docstring in this case because autodoc doesn't apply
+          Printv(f_shadow, tab4, docstring(n, AUTODOC_CLASS, tab4), "\n", NIL);
+      
       if (!modern) {
         Printv(f_shadow,tab4,"__swig_setmethods__ = {}\n",NIL);
         if (Len(base_class)) {
           Printf(f_shadow,"%sfor _s in [%s]: __swig_setmethods__.update(_s.__swig_setmethods__)\n",tab4,base_class);
@@ -1833,16 +2098,22 @@
 	  Delete(pyaction);
 	  Printv(f_shadow,pycode,"\n",NIL);
 	} else {
 
-          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "): ", NIL);
-          if ( have_addtofunc(n) ) {
-            Printv(f_shadow, "\n", NIL);
-            Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
-            Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-            Printv(f_shadow, tab8, "return val\n", NIL);
+          Printv(f_shadow, tab4, "def ", symname, "(*args", (allow_kwargs ? ", **kwargs" : ""), "):", NIL);
+          if ( ! have_addtofunc(n) && ! have_docstring(n)) {
+            Printv(f_shadow, " return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
           } else {
-            Printv(f_shadow, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+            Printv(f_shadow, "\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_FUNC, tab8), "\n", NIL);
+            if ( have_addtofunc(n) ) {
+              Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n", NIL);
+              Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+              Printv(f_shadow, tab8, "return val\n\n", NIL);
+            } else {
+              Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name,symname), allow_kwargs), "\n\n", NIL);
+            }
           }
         }
 
       }
@@ -1857,14 +2128,20 @@
   virtual int staticmemberfunctionHandler(Node *n) {
     String *symname = Getattr(n,"sym:name");
     Language::staticmemberfunctionHandler(n);
     if (shadow) {
-      if ( !classic && have_addtofunc(n) ) {
+      if ( !classic && (have_addtofunc(n) || have_docstring(n)) ) {
         int kw = (check_kwargs(n) && !Getattr(n,"sym:overloaded")) ? 1 : 0;
         Printv(f_shadow, tab4, "def ", symname, "(*args", (kw ? ", **kwargs" : ""), "):\n", NIL);
-        Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
-        Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
-        Printv(f_shadow, tab8, "return val\n", NIL);
+        if ( have_docstring(n) )
+          Printv(f_shadow, tab8, docstring(n, AUTODOC_STATICFUNC, tab8), "\n", NIL);
+        if ( have_addtofunc(n) ) {
+          Printv(f_shadow, tab8, "val = ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n", NIL);
+          Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+          Printv(f_shadow, tab8, "return val\n\n", NIL);
+        } else {
+          Printv(f_shadow, tab8, "return ", funcCallHelper(Swig_name_member(class_name, symname), kw), "\n\n", NIL);
+        }
         Printv(f_shadow, tab4, modern ? "" : "if _newclass:",  symname,
                " = staticmethod(", symname, ")\n", NIL);
 
         if (!modern) {
@@ -1949,8 +2226,10 @@
  	    }
 
             Printv(f_shadow, tab4, "def __init__(self, *args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_CTOR, tab8), "\n", NIL);
             Printv(f_shadow, pass_self, NIL);
             if (!modern) {
               Printv(f_shadow, tab8, "_swig_setattr(self, ", rclassname, ", 'this', ", 
                      funcCallHelper(Swig_name_construct(symname), allow_kwargs), ")\n", NIL);
@@ -1964,9 +2243,9 @@
               Printv(f_shadow, tab8, "self.thisown = 1\n", NIL);
               Printv(f_shadow, tab8, "del newobj.thisown\n", NIL);
             }
             if ( have_addtofunc(n) )
-              Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
+              Printv(f_shadow, tab8, addtofunc(n), "\n\n", NIL);
   	    Delete(pass_self);
   	  }
 	  have_constructor = 1;
 	} else {
@@ -1982,8 +2261,10 @@
 	  } else {
 
             Printv(f_shadow_stubs, "\ndef ", symname, "(*args",
                    (allow_kwargs ? ", **kwargs" : ""), "):\n", NIL);
+            if ( have_docstring(n) )
+              Printv(f_shadow_stubs, tab4, docstring(n, AUTODOC_CTOR, tab4), "\n", NIL);
             Printv(f_shadow_stubs, tab4, "val = ",
                    funcCallHelper(Swig_name_construct(symname), allow_kwargs), "\n", NIL);
 	    Printv(f_shadow_stubs, tab4, "val.thisown = 1\n", NIL);
             if ( have_addtofunc(n) )
@@ -2015,13 +2296,15 @@
 	Delete(pyaction);
 	Printv(f_shadow,pycode,"\n", NIL);
       } else {
 	Printv(f_shadow, tab4, "def __del__(self, destroy=", module, ".", Swig_name_destroy(symname), "):\n", NIL);
+        if ( have_docstring(n) )
+              Printv(f_shadow, tab8, docstring(n, AUTODOC_DTOR, tab8), "\n", NIL);
 	if ( have_addtofunc(n) )
 	  Printv(f_shadow, tab8, addtofunc(n), "\n", NIL);
 	Printv(f_shadow, tab8, "try:\n", NIL);
-	Printv(f_shadow, tab4, tab8, "if self.thisown: destroy(self)\n", NIL);
-	Printv(f_shadow, tab8, "except: pass\n", NIL);
+	Printv(f_shadow, tab8, tab4, "if self.thisown: destroy(self)\n", NIL);
+	Printv(f_shadow, tab8, "except: pass\n\n", NIL);
       }
     }
     return SWIG_OK;
   }
