\section{\class{wxBoxSizer}}\label{wxboxsizer}

The basic idea behind a box sizer is that windows will most often be laid out in rather 
simple basic geomerty, typically in a row or a column or several hierachies of either.

As an exmaple, we will construct a dialog that will contain a text field at the top and
two buttons at the bottom. This can be seen as a top-hierarchy column with the text at
the top and buttons at the bottom and a low-hierchary row with an OK button to the left
and a Cancel button to the right. In many cases (particulary dialogs under Unix and
normal frames) the main window will be resizable by the user and this change of size
will have to get propagated to its children. In our case, we want the text area to grow
with the dialog, whereas the button shall have a fixed size. In addition, there will be
a thin border around all controls to make the dialog look nice and - to make matter worse -
the buttons shall be centred as the width of the dialog changes.

It is the unique feature of a box sizer, that it can grow in both directions (height and
width) but can distribute its growth in the main direction (horizontal for a row) {\it unevenly}
among its children. In our example case, the vertical sizer is supposed to propagate all its
height changes to only the text area, not to the button area. This is determined by the
{\it option} parameter when adding a window (or another sizer) to a sizer. It is interpreted
as a weight factor, i.e. it can be zero, indicating that the window may not be resized
at all, or above zero. If several windows have a value above zero, the value is interpreted
relative to the sum of all weight factors of the sizer, so when adding two windows with
a value of 1, they will both get resized equally much and each half as much as the sizer 
owning them. Then what do we do when a column sizer changes its width? This behaviour is
controlled by {\it flags} (the second parameter of the Add() function): Zero or no flag indicates that
the window will get aligned at the left (in a column sizer) and the top (row sizer), whereas
wxALIGN\_RIGHT and wxALIGN\_BOTTOM will do what they say. The item can also be centered
using the wxCENTRE flag (same as wxCENTER) or it can be forced to grow with the sizer (using
the wxGROW flag (same as wxEXPAND)).

As mentioned above, any window belonging to a sizer may have border, and it can be specified
which of the four sides may have this border, using the wxTOP, wxLEFT, wxRIGHT and wxBOTTOM
constants or wxALL for all directions (and you may also use wxNORTH, wxWEST etc instead). These
flags can be used in combintaion with the alignement flags above as the second paramter of the
Add() method using the binary or operator |. The sizer of the border also must be made known,
and it is the third parameter in the Add() method. This means, that the entire behaviour of
a sizer and its children can be controlled by the three parameters of the Add() method.

\begin{verbatim}
// we want to get a dialog that is stretchable because it
// has a text ctrl at the top and two buttons at the bottom

MyDialog::MyDialog(wxFrame *parent, wxWindowID id, const wxString &title ) :
  wxDialog( parent, id, title, wxDefaultPosition, wxDefaultSize, wxDIALOG_STYLE | wxRESIZE_BORDER )
{
  wxBoxSizer *topsizer = new wxBoxSizer( wxVERTICAL );
  
  // create text ctrl with minimal size 100x60
  topsizer->Add( 
    new wxTextCtrl( this, -1, "My text.", wxDefaultPosition, wxSize(100,60), wxTE_MULTILINE),
    1,            // make vertically stretchable
    wxEXPAND |    // make horizontally stretchable
    wxALL,        //   and make border all around
    10 );         // set border width to 10


  wxBoxSizer *button_sizer = new wxBoxSizer( wxHORIZONTAL );
  button_sizer->Add(
     new wxButton( this, wxID_OK, "OK" ), 
     0,           // make horizontally unstretchable
     wxALL,       // make border all around (implicit top alignment)
     10 );        // set border width to 10
  button_sizer->Add(
     new wxButton( this, wxID_CANCEL, "Cancel" ), 
     0,           // make horizontally unstretchable
     wxALL,       // make border all around (implicit top alignment)
     10 );        // set border width to 10
  
  topsizer->Add( 
     button_sizer,
     0,          // make vertically unstretchable
     wxCENTER ); // no border and centre horizontally

  SetAutoLayout( TRUE );     // tell dialog to use sizer
  SetSizer( topsizer );      // actually set the sizer

  topsizer->Fit( this );            // set size to minimum size as calculated by the sizer
  topsizer->SetSizeHints( this );   // set size hints to honour mininum size
  
}
\end{verbatim}


\wxheading{Derived from}

\helpref{wxSizer}{wxsizer}

\latexignore{\rtfignore{\wxheading{Members}}}


\membersection{wxBoxSizer::wxBoxSizer}\label{wxboxsizerwxboxsizer}

\func{}{wxBoxSizer}{\param{int }{orient}}

Constructor for a wxBoxSizer. {\it orient} may be either of wxVERTICAL
or wxHORIZONTAL for creating either a column sizer or a row sizer.

\membersection{wxBoxSizer::RecalcSizes}\label{wxboxsizerrecalcsizes}

\func{void}{RecalcSizes}{\void}


\membersection{wxBoxSizer::CalcMin}\label{wxboxsizercalcmin}

\func{wxSize}{CalcMin}{\void}


\membersection{wxBoxSizer::GetOrientation}\label{wxboxsizergetorientation}

\func{int}{GetOrientation}{\void}

