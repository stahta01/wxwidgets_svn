\section{Extended Runtime Class Information (aka XTI) overview}\label{runtimeclassoverview}

\subsection{C++ standard RTTI and Java Reflection}\label{stdrtti}

Traditional C++ has limited support for programming with type information; 
it supports runtime type information (RTTI) that allows you to do little more 
than test the type of an expression. The \tt{type_info} class, the \tt{typeid} operator, 
and the \tt{dynamic_cast} operator are all that is available.

The \tt{type_info} class encapsulates type information generated by the compiler, 
and the \tt{typeid} operator allows the type of a class or an object to be tested 
at runtime. The \tt{dynamic_cast} operator just allows you to cast in a type-safe manner.

The architecture known under the name of \bf{reflection}, born originally in the Java
programming language, enables a program to dynamically 
analyze and discover elements (such as fields, methods, constructors, and attributes) of 
types (such as classes, interfaces, and structures) in existing binaries. 
The types may be instantiated, accessed, and invoked in a very dynamic and interactive manner, 
making it possible to implement interesting programming tools such as an interpreted test 
script language.

Reflection is not limited to analyzing existing compiled code;
it can also be used to dynamically generate new types that may then be instantiated 
and manipulated in the same way as any traditional source code–defined types. 
In fact, typically a program manipulates data; using reflection mechanisms, a program
manipulates not only data but also code, and then executes it.

\subsection{wxWidgets and XTI}\label{wxandxti}

wxWidgets does not provide a full reflection framework but rather provides
a system which still allows to do some of the useful (and fancy) things typical 
of the reflection mechanisms.

When \tt{wxUSE_EXTENDED_RTTI == 1} (the default), in fact, the eXtended runtime
Type Information (XTI) system of wxWidgets is enabled and compiled.
Such system is built using C++ RTTI and templates and provides many features:

\begin{enumerate}\itemsep=0pt
\item Ability to test if a class is a child/parent of another class (inheritance hierarchy checks).
\item Ability to walk through the list of the classes registered in the XTI system.
\item Ability to create a class instance supplying the class name into a \helpref{wxString}{wxstring}.
\item Ability to query the properties, handlers, events associated with a class.
\item Ability to serialize and deserialize a class.
\item Ability to create new classes at runtime.
\end{enumerate}

In particular the last feature is a typical feature of dynamic, interpreted languages
(e.g. Python, Lua, Ruby, etc), where you can manipulate data as well as code, and then 
execute it (through an \tt{eval()} function or similar, which simply takes a string
containing the source code to be executed).

When \tt{wxUSE_EXTENDED_RTTI == 0} instead the "old" RTTI system of wxWidgets is used;
it's not based on C++ RTTI and provides much less features compared to XTI
(i.e. only the first three items listed above).

Each class that you wish to be known to the XTI system should have
a macro such as \helpref{wxDECLARE\_DYNAMIC\_CLASS}{wxdeclaredynamicclass} just inside the 
class declaration.
The macro \helpref{wxIMPLEMENT\_DYNAMIC\_CLASS}{wximplementdynamicclass} should 
be in the implementation file.
Note that these macros are entirely optional; use them if you wish to get XTI
features on your classes; for those classes you're not interested to query their
properties at runtime, you can safely skip the macros.

Variations on these \helpref{macros}{rttimacros} are used for multiple inheritance, 
and abstract classes that cannot be instantiated dynamically or otherwise.

\helpref{wxDECLARE\_DYNAMIC\_CLASS}{wxdeclaredynamicclass} inserts a static 
\helpref{wxClassInfo}{wxclassinfo} declaration into the
class, initialized by \helpref{wxIMPLEMENT\_DYNAMIC\_CLASS}{wximplementdynamicclass}. 
When initialized, the \helpref{wxClassInfo}{wxclassinfo} object inserts itself into a 
linked list (which can be walked using the \helpref{wxClassInfo::GetFirst}{wxclassinfogetfirst}
and \helpref{wxClassInfo::GetNext}{wxclassinfogetnext} functions). The linked list
is fully created by the time all global initialization is done.

Note that many functions related to XTI take as argument a \helpref{wxClassInfo}{wxclassinfo}
pointer; you can use the \helpref{wxCLASSINFO}{wxclassinfomacro} to get the wxClassInfo
which belongs to a specific class.

\subsection{Example of the basic RTTI system}\label{runtimeclassinformationexample}

In a header file mywindow.h:

\begin{verbatim}
enum MyWindowStyle
{
    MWS_NICE,
    MWS_NORMAL,
    MWS_UGLY
};

class MyWindow : public wxWindow
{
    wxDECLARE_DYNAMIC_CLASS(MyWindow)

private:
    wxString m_title;

public:
    MyWindow() {}   // with wxDECLARE_DYNAMIC_CLASS() you need a default ctor!

    ...
    bool Create(wxWindow* parent, wxWindowID id, const wxString &title, long style);
    void SetTitle(const wxString &title);
    wxString GetTitle() const;
    ...
};
\end{verbatim}

In a C++ file mywindow.cpp:

\begin{verbatim}
wxIMPLEMENT_DYNAMIC_CLASS(MyWindow, wxWindow)

bool MyWindow::Create(wxWindow* parent, wxWindowID id, const wxString &title, long style)
{
...
}
\end{verbatim}


\subsection{Example of the advanced XTI system}\label{runtimeclassinformationexample2}

In a header file mywindow.h:

\begin{verbatim}
enum MyWindowStyle
{
    MWS_NICE,
    MWS_NORMAL,
    MWS_UGLY
};

class MyWindow : public wxWindow
{
    wxDECLARE_DYNAMIC_CLASS(MyWindow)

private:
    wxString m_title;

public:
    MyWindow() {}   // with wxDECLARE_DYNAMIC_CLASS() you need a default ctor!

    ...
    bool Create(wxWindow* parent, wxWindowID id, const wxString &title, long style);
    void SetTitle(const wxString &title);
    wxString GetTitle() const;
    ...
};
\end{verbatim}

As you can see the header file is perfectly identic with the header file of the 
"basic RTTI" sample above.

In a C++ file mywindow.cpp:

\begin{verbatim}

// describe the styles which can be used with MyWindow
wxDEFINE_FLAGS( MyWindowStyle )
wxBEGIN_FLAGS( MyWindowStyle )
    wxFLAGS_MEMBER(MWS_NICE)
    wxFLAGS_MEMBER(MWS_NORMAL)
    wxFLAGS_MEMBER(MWS_UGLY)
wxEND_FLAGS( MyWindowStyle )

// by using wxIMPLEMENT_DYNAMIC_CLASS_XTI instead of wxIMPLEMENT_DYNAMIC_CLASS
// we are then forced to define the properties & handlers table below, and also
// a constructor...
wxIMPLEMENT_DYNAMIC_CLASS_XTI(MyWindow, wxWindow, "mywindow.h")

// describe the properties of this class
wxBEGIN_PROPERTIES_TABLE(MyWindow)
    wxPROPERTY( Title, wxString, SetTitle, GetTitle, wxString(), \
                0 /*flags*/, wxT("The myWindow title"), wxT("none") )

    wxPROPERTY_FLAGS( WindowStyle, MyWindowStyle, long, SetWindowStyleFlag, \
                      GetWindowStyleFlag, EMPTY_MACROVALUE, 0 /*flags*/,     \
                      wxT("The myWindow style"), wxT("none"))
wxEND_PROPERTIES_TABLE()

// describe the handlers of this class
wxBEGIN_HANDLERS_TABLE(MyWindow)
wxEND_HANDLERS_TABLE()

// describe the constructor
wxCONSTRUCTOR_6( MyWindow, wxWindow*, Parent, wxWindowID, Id, wxString, Title, long, WindowStyle )
                                 

bool MyWindow::Create(wxWindow* parent, wxWindowID id, const wxString &title, long style)
{
...
}

// TODO: show sample code which does use XTI for some simple tasks.
\end{verbatim}

